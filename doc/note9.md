## メモリ管理
bootpack.cが大きくなってきたのでソース分割

メモリへのアクセスとレジスタへのアクセスだと、レジスタの方が圧倒的にはやい
しかしCPUに記憶する場所はない
そこでCPUの中にメモリを入れた。それをキャッシュメモリという
高速なメモリは、ものすごく高価、チップ一つでCPU位の値段する
機械語の流れを観察すると、９割以上の時間がループで消費されている。
キャッシュ制御回路すごい
386にはキャッシュメモリが無い、486にはわずか8~16KBのキャッシュがついただけで、処理性能差６倍
では64bitはどんくらい？
けどメモリチェックの際にキャッシュメモリが反応すると、正しいメモリ容量が分からない

コンパイラの最適化の話もしてくれる
今回はmemtest_subのアセンブリをみてみると無駄な命令が消えて、for文だけになってる

メモリ管理ってなんだ？
どの番地のメモリが使って良くて、どの番地のメモリが使っちゃいけないのかということを管理しなければいけない。
メモリ管理の基本は確保と解放

単純な方法を考えると、128mbを0x1000byte単位で管理するとして
0x08000000 /0x1000 = 0x8000 = 32768byteの領域を作って,そこに0,1を書き込んで管理

すこし問題があるメモリ容量の0.02%使うことになる。
bit管理表にすれば0.003%になる

上の方法に代わる方法として
hoge番地からfugaバイトあいてるよーっていう情報を表にする
最初はリストは一件になるね
この方法だと最初の方法よりすごくはやい
最初のほうほうだとたくさん書き込む必要がある、がこの方法だと足し算、引き算を一回ずつ行うだけ
確保容量が多くても少なくても変わらない。

いまもメモリ管理はこんなアルゴリズムなのかな？
やっぱ実際にはあいているのに使用中だと誤解されて、使えなくなるメモリもでてくるよね
実際OSはいろいろ工夫してなんとかしている


